MqttClient {
  options: {
    protocol: 'mqtts',
    slashes: true,
    auth: null,
    host: 'localhost',
    port: 8883,
    hostname: 'localhost',
    hash: null,
    search: null,
    query: [Object: null prototype] {},
    pathname: null,
    href: 'mqtts://localhost:8883',
    clientId: 'mqtt_d4e8977bb17c',
    clean: true,
    key: <Buffer 2d 2d 2d 2d 2d 42 45 47 49 4e 20 50 52 49 56 41 54 45 20 4b 45 59 2d 2d 2d 2d 2d 0a 4d 49 49 45 76 51 49 42 41 44 41 4e 42 67 6b 71 68 6b 69 47 39 77 ... 1654 more bytes>,
    cert: <Buffer 2d 2d 2d 2d 2d 42 45 47 49 4e 20 43 45 52 54 49 46 49 43 41 54 45 2d 2d 2d 2d 2d 0a 4d 49 49 44 61 54 43 43 41 6c 45 43 46 44 57 4a 57 30 6e 55 70 59 ... 1195 more bytes>,
    rejectUnauthorized: false,
    ca: <Buffer 2d 2d 2d 2d 2d 42 45 47 49 4e 20 43 45 52 54 49 46 49 43 41 54 45 2d 2d 2d 2d 2d 0a 4d 49 49 44 77 7a 43 43 41 71 75 67 41 77 49 42 41 67 49 55 4e 52 ... 1317 more bytes>,
    defaultProtocol: 'mqtts',
    keepalive: 60,
    reschedulePings: true,
    protocolId: 'MQTT',
    protocolVersion: 4,
    reconnectPeriod: 1000,
    connectTimeout: 30000,
    resubscribe: true,
    customHandleAcks: [Function (anonymous)],
    servername: 'localhost'
  },
  streamBuilder: [Function: wrapper],
  messageIdProvider: DefaultMessageIdProvider { nextId: 43018 },
  outgoingStore: Store { options: { clean: true }, _inflights: Map(0) {} },
  incomingStore: Store { options: { clean: true }, _inflights: Map(0) {} },
  queueQoSZero: true,
  _resubscribeTopics: {},
  messageIdToTopic: {},
  pingTimer: null,
  connected: false,
  disconnecting: false,
  queue: [],
  connackTimer: Timeout {
    _idleTimeout: 30000,
    _idlePrev: [TimersList],
    _idleNext: [TimersList],
    _idleStart: 250,
    _onTimeout: [Function (anonymous)],
    _timerArgs: undefined,
    _repeat: null,
    _destroyed: false,
    [Symbol(refed)]: true,
    [Symbol(kHasPrimitive)]: false,
    [Symbol(asyncId)]: 12,
    [Symbol(triggerId)]: 1
  },
  reconnectTimer: null,
  _storeProcessing: false,
  _packetIdsDuringStoreProcessing: {},
  _storeProcessingQueue: [],
  outgoing: {},
  _firstConnection: true,
  _events: [Object: null prototype] {
    connect: [Function (anonymous)],
    close: [Function (anonymous)],
    error: [Function (anonymous)]
  },
  _eventsCount: 3,
  _maxListeners: undefined,
  stream: <ref *1> TLSSocket {
    _tlsOptions: {
      allowHalfOpen: undefined,
      pipe: false,
      secureContext: [SecureContext],
      isServer: false,
      requestCert: true,
      rejectUnauthorized: false,
      session: undefined,
      ALPNProtocols: undefined,
      requestOCSP: undefined,
      enableTrace: undefined,
      pskCallback: undefined,
      highWaterMark: undefined,
      onread: undefined,
      signal: undefined
    },
    _secureEstablished: false,
    _securePending: false,
    _newSessionPending: false,
    _controlReleased: true,
    secureConnecting: true,
    _SNICallback: null,
    servername: null,
    alpnProtocol: null,
    authorized: false,
    authorizationError: null,
    encrypted: true,
    _events: [Object: null prototype] {
      close: [Array],
      end: [Array],
      newListener: [Array],
      connect: [Function],
      secure: [Function: onConnectSecure],
      secureConnect: [Function (anonymous)],
      error: [Array],
      data: [Function: ondata]
    },
    _eventsCount: 8,
    connecting: true,
    _hadError: false,
    _parent: null,
    _host: 'localhost',
    _readableState: ReadableState {
      objectMode: false,
      highWaterMark: 16384,
      buffer: BufferList { head: null, tail: null, length: 0 },
      length: 0,
      pipes: [Array],
      flowing: true,
      ended: false,
      endEmitted: false,
      reading: false,
      constructed: true,
      sync: true,
      needReadable: false,
      emittedReadable: false,
      readableListening: false,
      resumeScheduled: true,
      errorEmitted: false,
      emitClose: false,
      autoDestroy: true,
      destroyed: false,
      errored: null,
      closed: false,
      closeEmitted: false,
      defaultEncoding: 'utf8',
      awaitDrainWriters: null,
      multiAwaitDrain: false,
      readingMore: false,
      dataEmitted: false,
      decoder: null,
      encoding: null,
      [Symbol(kPaused)]: false
    },
    _maxListeners: 1000,
    _writableState: WritableState {
      objectMode: false,
      highWaterMark: 16384,
      finalCalled: false,
      needDrain: false,
      ending: false,
      ended: false,
      finished: false,
      destroyed: false,
      decodeStrings: false,
      defaultEncoding: 'utf8',
      length: 31,
      writing: false,
      corked: 1,
      sync: true,
      bufferProcessing: false,
      onwrite: [Function: bound onwrite],
      writecb: null,
      writelen: 0,
      afterWriteTickInfo: null,
      buffered: [Array],
      bufferedIndex: 0,
      allBuffers: false,
      allNoop: true,
      pendingcb: 9,
      constructed: true,
      prefinished: false,
      errorEmitted: false,
      emitClose: false,
      autoDestroy: true,
      errored: null,
      closed: false,
      closeEmitted: false,
      [Symbol(kOnFinished)]: []
    },
    allowHalfOpen: false,
    _sockname: null,
    _pendingData: null,
    _pendingEncoding: '',
    server: undefined,
    _server: null,
    ssl: TLSWrap {
      _parent: [TCP],
      _parentWrap: undefined,
      _secureContext: [SecureContext],
      reading: false,
      onkeylog: [Function: onkeylog],
      onhandshakestart: {},
      onhandshakedone: [Function (anonymous)],
      onocspresponse: [Function: onocspresponse],
      onnewsession: [Function: onnewsessionclient],
      onerror: [Function: onerror],
      [Symbol(owner_symbol)]: [Circular *1]
    },
    _requestCert: true,
    _rejectUnauthorized: false,
    [Symbol(res)]: TLSWrap {
      _parent: [TCP],
      _parentWrap: undefined,
      _secureContext: [SecureContext],
      reading: false,
      onkeylog: [Function: onkeylog],
      onhandshakestart: {},
      onhandshakedone: [Function (anonymous)],
      onocspresponse: [Function: onocspresponse],
      onnewsession: [Function: onnewsessionclient],
      onerror: [Function: onerror],
      [Symbol(owner_symbol)]: [Circular *1]
    },
    [Symbol(verified)]: false,
    [Symbol(pendingSession)]: null,
    [Symbol(async_id_symbol)]: 5,
    [Symbol(kHandle)]: TLSWrap {
      _parent: [TCP],
      _parentWrap: undefined,
      _secureContext: [SecureContext],
      reading: false,
      onkeylog: [Function: onkeylog],
      onhandshakestart: {},
      onhandshakedone: [Function (anonymous)],
      onocspresponse: [Function: onocspresponse],
      onnewsession: [Function: onnewsessionclient],
      onerror: [Function: onerror],
      [Symbol(owner_symbol)]: [Circular *1]
    },
    [Symbol(kSetNoDelay)]: false,
    [Symbol(lastWriteQueueSize)]: 0,
    [Symbol(timeout)]: null,
    [Symbol(kBuffer)]: null,
    [Symbol(kBufferCb)]: null,
    [Symbol(kBufferGen)]: null,
    [Symbol(kCapture)]: false,
    [Symbol(kBytesRead)]: 0,
    [Symbol(kBytesWritten)]: 0,
    [Symbol(connect-options)]: {
      rejectUnauthorized: false,
      ciphers: 'TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA',
      checkServerIdentity: [Function: checkServerIdentity],
      minDHSize: 1024,
      protocol: 'mqtts',
      slashes: true,
      auth: null,
      host: 'localhost',
      port: 8883,
      hostname: 'localhost',
      hash: null,
      search: null,
      query: [Object: null prototype] {},
      pathname: null,
      href: 'mqtts://localhost:8883',
      clientId: 'mqtt_d4e8977bb17c',
      clean: true,
      key: <Buffer 2d 2d 2d 2d 2d 42 45 47 49 4e 20 50 52 49 56 41 54 45 20 4b 45 59 2d 2d 2d 2d 2d 0a 4d 49 49 45 76 51 49 42 41 44 41 4e 42 67 6b 71 68 6b 69 47 39 77 ... 1654 more bytes>,
      cert: <Buffer 2d 2d 2d 2d 2d 42 45 47 49 4e 20 43 45 52 54 49 46 49 43 41 54 45 2d 2d 2d 2d 2d 0a 4d 49 49 44 61 54 43 43 41 6c 45 43 46 44 57 4a 57 30 6e 55 70 59 ... 1195 more bytes>,
      ca: <Buffer 2d 2d 2d 2d 2d 42 45 47 49 4e 20 43 45 52 54 49 46 49 43 41 54 45 2d 2d 2d 2d 2d 0a 4d 49 49 44 77 7a 43 43 41 71 75 67 41 77 49 42 41 67 49 55 4e 52 ... 1317 more bytes>,
      defaultProtocol: 'mqtts',
      keepalive: 60,
      reschedulePings: true,
      protocolId: 'MQTT',
      protocolVersion: 4,
      reconnectPeriod: 1000,
      connectTimeout: 30000,
      resubscribe: true,
      customHandleAcks: [Function (anonymous)],
      servername: 'localhost',
      singleUse: true
    }
  },
  [Symbol(kCapture)]: false
}

mqtt pub -t 'hello' -h 'localhost'  -m 'from MQTT.js' -p 1883 --key ./certs/server.key --cert ./certs.server.crt --ca ./certs/ca.crt

'use strict'

const mqtt = require('../..')
const path = require('path')
const fs = require('fs')
const KEY = fs.readFileSync(path.join(__dirname, '..', '..', 'test', 'helpers', 'tls-key.pem'))
const CERT = fs.readFileSync(path.join(__dirname, '..', '..', 'test', 'helpers', 'tls-cert.pem'))

const PORT = 8443

const options = {
  port: PORT,
  key: KEY,
  cert: CERT,
  rejectUnauthorized: false 
}

const client = mqtt.connect(options)

client.subscribe('messages')
client.publish('messages', 'Current time is: ' + new Date())
client.on('message', function (topic, message) {
  console.log(message)
})